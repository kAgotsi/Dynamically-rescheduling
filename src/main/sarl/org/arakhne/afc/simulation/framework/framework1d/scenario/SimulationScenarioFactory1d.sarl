/* 
 * $Id$
 * This file is a part of the Arakhne Foundation Classes, http://www.arakhne.org/afc
 * 
 * Copyright (c) 2000-2012 Stephane GALLAND.
 * Copyright (c) 2005-10, Multiagent Team, Laboratoire Systemes et Transports,
 * Universite de Technologie de Belfort-Montbeliard.
 * Copyright (c) 2013-2019 The original authors, and other authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.arakhne.afc.simulation.framework.framework1d.scenario

import io.sarl.lang.core.Agent
import io.sarl.lang.util.OutParameter
import java.io.File
import java.util.Collection
import java.util.Date
import java.util.List
import java.util.Map
import java.util.ResourceBundle
import java.util.UUID
import javafx.scene.chart.LineChart
import javafx.scene.chart.NumberAxis
import javafx.scene.chart.XYChart
import org.arakhne.afc.gis.mapelement.MapElement
import org.arakhne.afc.gis.maplayer.MapElementLayer
import org.arakhne.afc.gis.maplayer.MultiMapLayer
import org.arakhne.afc.gis.maplayer.TreeMapElementLayer
import org.arakhne.afc.gis.primitive.GISContainer
import org.arakhne.afc.gis.road.layer.RoadNetworkLayer
import org.arakhne.afc.gis.road.primitive.RoadSegment
import org.arakhne.afc.math.stochastic.StochasticLaw
import org.arakhne.afc.simulation.framework.base.config.ChartConfig
import org.arakhne.afc.simulation.framework.base.config.SpawnerConfig
import org.arakhne.afc.simulation.framework.base.fx.preferences.AbstractFxPreferenceManager
import org.arakhne.afc.simulation.framework.base.fx.probes.DynamicLineChart
import org.arakhne.afc.simulation.framework.base.probes.DefaultProbeManager
import org.arakhne.afc.simulation.framework.base.probes.Probe
import org.arakhne.afc.simulation.framework.base.probes.ProbeManager
import org.arakhne.afc.simulation.framework.base.scenario.SimulationScenarioFactory
import org.arakhne.afc.simulation.framework.framework1d.config.AbstractConfiguration1d
import org.arakhne.afc.simulation.framework.framework1d.environment.EnvironmentModel1d
import org.arakhne.afc.simulation.framework.framework1d.environment.MobileAgentBody
import org.arakhne.afc.simulation.framework.framework1d.environment.RoadObject
import org.arakhne.afc.simulation.framework.framework1d.environment.Spawner1d
import org.arakhne.afc.simulation.framework.framework1d.preferences.PreferenceManager1d
import org.arakhne.afc.simulation.framework.framework1d.probes.EnvironmentLocalProbe1d
import org.arakhne.afc.vmutil.ReflectionUtil

import static extension org.arakhne.afc.util.ResourceBundles.*
import static extension org.arakhne.afc.vmutil.FileSystem.*
import static extension org.arakhne.afc.vmutil.ReflectionUtil.*

/**
 * Reader of Simulation scenario.
 *
 * @param <T> the type of the configuration to read.
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
class SimulationScenarioFactory1d<T extends AbstractConfiguration1d> implements SimulationScenarioFactory<SimulationScenario1d<T>> {

	val shapeReader = new ShapeReader

	val xmlReader : AbstractXmlConfigurationReader1d<T>
	
	new (xmlReader : AbstractXmlConfigurationReader1d<T>) {
		assert xmlReader !== null
		this.xmlReader = xmlReader
	}

	protected def getCarWidth : double {
		PreferenceManager1d::singleton.carWidth
	}

	protected def getCarHeight : double {
		PreferenceManager1d::singleton.carHeight
	}
	
	/** Read standard layers from the simulation configuration and include them into the simulation scenario.
	 * 
	 * @param configuration the simulation configuration.
	 * @param loadedRoads the layer that contains the loaded roads.
	 * @param containers the collection of layers that must be included into the simulation. 
	 */
	protected def loadStandardLayers(configuration : T, loadedRoads : RoadNetworkLayer,
		containers : List<MapElementLayer<?>>) : void {
		for (layer : configuration.layers) {
			var loadedResource = this.shapeReader.loadShapeFile(layer.file)
			if (loadedResource !== null) {
				loadedResource.UUID = layer.ID
				var id = layer.name
				if (!id.isNullOrEmpty) {
					loadedResource.name = id
				}
				containers.add(loadedResource)
			}
		}
	}

	/** Read road objects from the simulation configuration and include them into the simulation scenario.
	 * 
	 * @param configuration the simulation configuration.
	 * @param loadedRoads the layer that contains the loaded roads.
	 * @param containers the collection of layers that must be included into the simulation. 
	 * @param objectAgents the mapping between the object ID and the types of the agents that
	 *     should be associated to the objects.
	 */
	protected def loadRoadObjects(configuration : T, loadedRoads : RoadNetworkLayer,
		containers : List<MapElementLayer<?>>, objectAgents : Collection<Map<UUID, Class<? extends Agent>>>) : void {
		var network = loadedRoads.roadNetwork
		for (group : configuration.roadObjectGroups) {
			var objectLayer = new TreeMapElementLayer
			var groupMapping = newTreeMap(null)
			for (obj : group.roadObjects) {
				var pos1d = network.getNearestPositionOnRoadBorder(obj.position)
				var id = obj.ID
				var text = obj.text
				var instance : RoadObject
				if (text.nullOrEmpty) {
					instance = obj.type.newInstance(id, pos1d, obj.position)
				} else {
					instance = obj.type.newInstance(id, pos1d, obj.position, text)
				}
				(instance.roadPosition.segment as RoadSegment).addUserData(
					EnvironmentModel1d::IMMOBILE_OBJECTS_ATTRIBUTE_NAME, instance)
				if (instance instanceof MapElement) {
					objectLayer.addMapElement(instance)
				}
				// Create an associated agent.
				var agentType = obj.agentType
				if (agentType !== null) {
					groupMapping.put(instance.UUID, agentType)
				}
			}
			if (!objectLayer.isEmpty) {
				containers.add(objectLayer)
			}
			if (!groupMapping.isEmpty) {
				objectAgents += groupMapping
			}
		}
	}

	/** Read spawners from the simulation configuration and include them into the simulation scenario.
	 *
	 * @param root the root folder.
	 * @param configuration the simulation configuration.
	 * @param loadedRoads the layer that contains the loaded roads.
	 * @param containers the collection of layers that must be included into the simulation. 
	 * @param spawners the collection of spawners that must be included into the simulation.
	 */
	protected def loadSpawners(root : File, configuration : T, loadedRoads : RoadNetworkLayer,
		containers : List<MapElementLayer<?>>, spawners : List<Spawner1d>) : void {
		var network = loadedRoads.roadNetwork
		for (obj : configuration.spawners) {
			if (obj.agentType !== null) {
				var pos1d = network.getNearestPosition(obj.position)
				var id = obj.ID
				var law = obj.createLawObject
				if (law !== null) {
					var bt0 = obj.bodyType
					var bt1 : Class<? extends MobileAgentBody>
					if (bt0 !== null && typeof(MobileAgentBody).isAssignableFrom(bt0)) {
						bt1 = bt0.asSubclass(typeof(MobileAgentBody))
					} else {
						bt1 = typeof(MobileAgentBody)
					}
					var spawner = new Spawner1d(pos1d,
						getCarWidth, getCarHeight,
						id, law, obj.budget, obj.agentType, bt1)
					spawners += spawner
				}
			}
		}
	}

	/** Read probes from the simulation configuration.
	 * 
	 * @param root the root folder.
	 * @param configuration the simulation configuration.
	 * @param loadedRoads the roads.
	 * @param containers the other layers
	 * @param probeManager the receive of the probe manager.
	 */
	protected def loadProbeManager(root : File, configuration : T, loadedRoads : RoadNetworkLayer,
		containers : List<MapElementLayer<?>>,
		probeManager : OutParameter<ProbeManager>) {
		var network = loadedRoads.roadNetwork
		var probeFolder = configuration.probeFolder
		if (probeFolder !== null) {
			probeFolder = probeFolder.makeAbsolute(root)
		} else {
			probeFolder = root
		}
		val manager = createProbeManager(probeFolder, configuration.date)
		for (config : configuration.probes) {
			var type = config.type
			var probe : Probe
			try {
				probe = type.newInstance(config, manager.rootFolder, loadedRoads, containers)
			} catch (ex0 : Throwable) {
				probe = null
			}
			if (probe === null) {
				try {
					probe = type.newInstance(config, manager.rootFolder, loadedRoads)
				} catch (ex0 : Throwable) {
					probe = null
				}
			}
			if (probe === null) {
				try {
					probe = type.newInstance(config, manager.rootFolder, containers)
				} catch (ex0 : Throwable) {
					probe = null
				}
			}
			if (probe === null) {
				try {
					probe = type.newInstance(config, manager.rootFolder)
				} catch (ex0 : Throwable) {
					probe = null
				}
			}
			if (probe === null) {
				try {
					probe = type.newInstance(config)
				} catch (ex0 : Throwable) {
					probe = null
				}
			}
			if (probe === null) {
				probe = type.newInstance
			}
			if (probe !== null) {
				probe.name = config.name
				probe.ID = config.ID
				if (probe instanceof EnvironmentLocalProbe1d) {
					var pos1d = network.getNearestPosition(config.position)
					probe.position = pos1d
				}
				manager.addProbe(probe)
			}
		}
		probeManager.set(manager)
	}

	/** Create a line chart.
	 *
	 * @param generalCfg the general configuration.
	 * @param chartCfg the chart's configuration.
	 * @param bundle the localization resource bundle.
	 */
	protected def createLineChart(generalCfg : T, chartCfg : ChartConfig, bundle : ResourceBundle) : LineChart<Double, Double> {
		var xLabel = bundle.getStringOrKey("xAxisLabelTime")
		var xAxis = new NumberAxis
		var stepVal = generalCfg.timeConfig.step
		var startVal = generalCfg.timeConfig.start
		xAxis.autoRanging = false
		xAxis.lowerBound = startVal
		var range = AbstractFxPreferenceManager::singleton.chartXRangeFactorProperty.multiply(stepVal)
		var max = xAxis.lowerBoundProperty.add(range)
		xAxis.upperBoundProperty.bind(max)
		xAxis.tickUnitProperty.bind(range.divide(10.0))
		xAxis.label = xLabel
		var yAxis = new NumberAxis
		yAxis.label = chartCfg.YLabel
		var chart : LineChart<Double, Double> = new DynamicLineChart(xAxis, yAxis)
		chart.title = chartCfg.title
		return chart
	}

	/** Read probes from the simulation configuration.
	 * 
	 * @param root the root folder.
	 * @param configuration the simulation configuration.
	 * @param bundle the localization resource bundle.
	 * @param probeManager the receive of the probe manager.
	 */
	protected def loadCharts(root : File, configuration : T, 
			bundle : ResourceBundle,
			probeManager : ProbeManager,
			charts : Map<UUID, XYChart<Double, Double>>) {
		for (cfg : configuration.charts) {
			var chart : XYChart<Double, Double>
			switch (cfg.type) {
				case LINE: {
					chart = createLineChart(configuration, cfg, bundle)
				}
			}
			charts.put(cfg.ID, chart)
		}

		for (probe : probeManager.probes) {
			var series = probe.chartSeries
			if (series !== null) {
				var id = probe.ID
				var cfg = configuration.getProbe(id)
				if (cfg !== null) {
					for (chartId : cfg.charts) {
						var chart = charts.get(chartId)
						if (chart !== null) {
							chart.data += series
						}
					}
				}
			}
		}
	}

	protected def getStochasticLawType(name : String) : Class<? extends StochasticLaw> {
		var type : Class<?>
		try {
			type = ReflectionUtil::forName(name)
		} catch (e0 : Throwable) {
			var nn = typeof(StochasticLaw).package.name + "." + name.toFirstUpper
			try {
				type = ReflectionUtil::forName(nn)
			} catch (e1 : Throwable) {
				try {
					type = ReflectionUtil::forName(nn + "StochasticLaw")
				} catch (e2 : Throwable) {
				//
				}
			}
		}
		if (type !== null && typeof(StochasticLaw).isAssignableFrom(type)) {
			return type.asSubclass(typeof(StochasticLaw))
		}
		return null;
	}

	protected def createLawObject(config : SpawnerConfig) : StochasticLaw {
		var type = config.law.getStochasticLawType
		if (type !== null) {
			try {
				return type.newInstance(config.lawArguments)
			} catch (e : Throwable) {
				//
			}
		}
		return null
	}

	/** Read a simulation scenario and create the simulation infrastructure.
	 * 
	 * @param root the root folder.
	 * @param configuration the simulation configuration.
	 * @param bundle the localization resource bundle
	 * @param loadedRoads the layer that contains the loaded roads.
	 * @param containers the collection of layers that must be included into the simulation.
	 * @param objectAgents the mapping between the object ID and the types of the agents that
	 *     should be associated to the objects.
	 * @param spawners the collection of spawners that must be included into the simulation.
	 * @param probeManager the receiver of the probe manager.
	 */
	protected def buildSimulationScenario(root : File, configuration : T,
			bundle : ResourceBundle,
			loadedRoads : RoadNetworkLayer,
			containers : List<MapElementLayer<?>>,
			objectAgents : Collection<Map<UUID, Class<? extends Agent>>>,
			spawners : List<Spawner1d>, probeManager : OutParameter<ProbeManager>, 
			charts : Map<UUID, XYChart<Double, Double>>) : void {
		loadStandardLayers(configuration, loadedRoads, containers)
		loadRoadObjects(configuration, loadedRoads, containers, objectAgents)
		loadSpawners(root, configuration, loadedRoads, containers, spawners)
		loadProbeManager(root, configuration, loadedRoads, containers, probeManager)
		var pm = probeManager.get
		if (pm !== null) {
			loadCharts(root, configuration, bundle, pm, charts)
		}
	}

	/** Read a simulation scenario and create the simulation infrastructure.
	 *
	 * @param file the simulation scenario file to read.
	 * @param bundle the localization bundle to be used.
	 * @return the scenario description. 
	 */
	def buildSimulationScenario(file : File, bundle : ResourceBundle) : SimulationScenario1d<T> {
		assert file !== null
		var configuration = this.xmlReader.loadXmlConfiguration(file, bundle)

		val containers = newArrayList
		var loadedRoads = this.shapeReader.loadRoads(configuration.roadNetwork)
		if (loadedRoads !== null) {
			containers.add(loadedRoads)
			var spawners = <Spawner1d>newArrayList
			var objectAgents = newArrayList
			var probeManager = new OutParameter
			var charts = <UUID, XYChart<Double, Double>>newTreeMap(null)
			buildSimulationScenario(
				file.parentFile, configuration, bundle, loadedRoads, containers,
				objectAgents, spawners, probeManager, charts)
			var container : GISContainer<?>
			if (containers.size == 1) {
				container = containers.get(0)
			} else {
				val layer = new MultiMapLayer
				for (child : containers) {
					layer.addMapLayer(child)
				}
				container = layer;
			}

			var environmentModel = loadedRoads.createEnvironmentModel

			return new SimulationScenario1d(container, environmentModel, configuration, objectAgents, spawners,
				probeManager.get, charts)
		}
	}

	/** Create the instance of the environment model.
	 *
	 * @param roads the loaded roads.
	 * @return the environment model.
	 */
	protected def createEnvironmentModel(roads : RoadNetworkLayer) : EnvironmentModel1d {
		new EnvironmentModel1d(roads)
	}

	/** Create the instance of the probe manager.
	 * 
	 * @param rootFolder the folder in which the data must be written.
	 * @param startTime the time at which the simulation has started.
	 * @return the manager.
	 */
	protected def createProbeManager(rootFolder : File, startTime : Date) : ProbeManager {
		new DefaultProbeManager(rootFolder, startTime)
	}

}
