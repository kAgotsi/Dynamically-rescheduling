/* 
 * $Id$
 * This file is a part of the Arakhne Foundation Classes, http://www.arakhne.org/afc
 * 
 * Copyright (c) 2000-2012 Stephane GALLAND.
 * Copyright (c) 2005-10, Multiagent Team, Laboratoire Systemes et Transports,
 * Universite de Technologie de Belfort-Montbeliard.
 * Copyright (c) 2013-2019 The original authors, and other authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.arakhne.afc.simulation.framework.base.fx.preferences

import com.dlsc.formsfx.model.validators.DoubleRangeValidator
import com.dlsc.formsfx.model.validators.IntegerRangeValidator
import com.dlsc.preferencesfx.model.Setting
import com.dlsc.preferencesfx.util.Constants
import java.io.File
import java.util.prefs.Preferences
import javafx.beans.property.BooleanProperty
import javafx.beans.property.DoubleProperty
import javafx.beans.property.IntegerProperty
import javafx.beans.property.ObjectProperty
import javafx.beans.property.SimpleBooleanProperty
import javafx.beans.property.SimpleDoubleProperty
import javafx.beans.property.SimpleIntegerProperty
import javafx.beans.property.SimpleObjectProperty
import org.arakhne.afc.simulation.framework.base.preferences.AbstractPreferenceManager
import org.arakhne.afc.simulation.framework.base.preferences.PreferenceManager

/** 
 * Manager of preferences for a simulator.
 *
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
abstract class AbstractFxPreferenceManager extends AbstractPreferenceManager implements PreferenceCategoryProvider {

	public static val PREFERENCES_CATEGORY_FILESYSTEM = "FILESYSTEM"

	public static val PREFERENCES_GROUP_FILESYSTEM_PREFERREDFILES = "PFILES"

	public static val PREFERENCES_CATEGORY_LOGGING = "LOGGING"

	public static val PREFERENCES_GROUP_LOGGING_GENERAL = "GENERAL"

	public static val PREFERENCES_GROUP_LOGGING_COLORS = "COLORS"

	public static val PREFERENCES_CATEGORY_SIMULATION = "SIMULATION"

	public static val PREFERENCES_GROUP_SIMULATION_TIME = "TIME"

	public static val PREFERENCES_GROUP_SIMULATION_EXECUTION = "EXECUTION"

	public static val PREFERENCES_CATEGORY_CHARTS = "CHARTS"

	public static val PREFERENCES_GROUP_CHARTS_GENERAL = "CHARTGENERAL"

	var storageHandlerObject : PreferenceStorage

	protected final override getStore : Preferences {
		this.storageHandler.preferences
	}

	/** Replies the storage handler used by this manager.
	 */
	final def getStorageHandler : PreferenceStorage {
		if (this.storageHandlerObject === null) {
			this.storageHandlerObject = new PreferenceStorage(this.storageClass)
		}
		return this.storageHandlerObject
	}

	/** Replies the singleton.
	 */
	static def getSingleton : AbstractFxPreferenceManager {
		PreferenceManager::singleton as AbstractFxPreferenceManager
	}

	protected override prefFile(name : String, defaultValue : File = null, enableJson : boolean = true) : File {
		super.prefFile(name.hashName, defaultValue, enableJson)
	}
	
	protected override prefDouble(name : String, defaultValue : double = 0.0) : double {
		super.prefDouble(name.hashName, defaultValue)
	}
	
	protected override prefInt(name : String, defaultValue : int = 0) : int {
		super.prefInt(name.hashName, defaultValue)
	}
	
	protected override prefBoolean(name : String, defaultValue : boolean = false) : boolean {
		super.prefBoolean(name.hashName, defaultValue)
	}

	/** 
	 * Encode the key to be compliant with {@link Preferences} contraints.
	 * 
	 * <p>Since {@link Preferences#MAX_KEY_LENGTH} is 80, if the name is over 80 characters, it
	 * will lead to an exception while saving.
	 *
	 * <p>The PreferencesFx API generates a SHA-256 hash of a String for names.
	 *
	 * <p>The behavior from PreferencesFx API is replaced in order to use the UUID/MD5 hash if
	 * the length of the name is longer than {@link Preferences#MAX_KEY_LENGTH}.
	 * 
	 * @param name the name to encode. 
	 * @return MD5 representation of the name.
	 */
	protected def hashName(name : String) : String {
		return getStorageHandler.hash(name)
	}

	protected static def name(names : String*) : String {
		val buffer = new StringBuffer
		if (names.length > 0) {
			buffer.append(names.get(0))
			for (var i = 1; i < names.length; i++) {
				var nm = names.get(i)
				if (!nm.nullOrEmpty) {
					buffer.append(Constants::BREADCRUMB_DELIMITER)
					buffer.append(nm)
				}
			}
		}
		return buffer.toString as String
	}

	def buildPreferenceCategories(extension builder : PreferenceCategoryBuilder) {
		builder.create(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_GENERAL,
			Setting::of(LOG_ON_CONSOLE, this.logOnConsoleProperty))

		builder.create(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS,
			ofColorType(LOG_ERROR_COLOR, this.logErrorColorProperty))
		builder.create(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS,
			ofColorType(LOG_WARNING_COLOR, this.logWarningColorProperty))
		builder.create(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS,
			ofColorType(LOG_INFO_COLOR, this.logInfoColorProperty))

		builder.create(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME,
			Setting::of(SIMULATION_START_TIME, this.simulationStartTimeProperty)
			.validate(DoubleRangeValidator::atLeast(0.0, "MUST_BE_POSITIVE_OR_ZERO")))
		builder.create(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME,
			Setting::of(SIMULATION_TIME_STEP, this.simulationStepDurationProperty)
			.validate(DoubleRangeValidator::atLeast(0.0, "MUST_BE_POSITIVE_OR_ZERO")))
		builder.create(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME,
			Setting::of(SIMULATION_DEFAULT_OS_TIME_FACTOR, this.simulationDefaultOsTimeFactorProperty)
			.validate(DoubleRangeValidator::atLeast(0.0, "MUST_BE_POSITIVE_OR_ZERO")))

		builder.create(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_EXECUTION,
			Setting::of(SIMULATION_LOOP_DELAY, this.simulationLoopDelayProperty)
			.validate(IntegerRangeValidator::atLeast(0, "MUST_BE_POSITIVE_OR_ZERO")))

		builder.create(PREFERENCES_CATEGORY_CHARTS, PREFERENCES_GROUP_CHARTS_GENERAL,
			Setting::of(CHART_X_RANGE_FACTOR, this.chartXRangeFactorProperty).validate(
				DoubleRangeValidator::atLeast(0, "MUST_BE_POSITIVE_OR_ZERO")))
	}

	override reset {
		resetLastOpenedDirectory
		resetLastOpenedFile
		resetSimulationStartTime
		resetSimulationStopTime
		resetSimulationStepDuration
		resetSimulationLoopDelay
		resetSimulationDefaultOsTimeFactor
		resetLogErrorColor
		resetLogWarningColor
		resetLogInfoColor
		resetLogOnConsole
		resetChartXRangeFactor
	}

	protected override saveProperties {
		saveLastOpenedDirectory
		saveLastOpenedFile
		saveSimulationStartTime
		saveSimulationStopTime
		saveSimulationStepDuration
		saveSimulationLoopDelay
		saveSimulationDefaultOsTimeFactor
		saveLogErrorColor
		saveLogWarningColor
		saveLogInfoColor
		saveLogOnConsole
		saveChartXRangeFactor
	}




	var lastOpenedDirectory : ObjectProperty<File>
	
	/** Replies the property that contains the last opened directory.
	 */
	def getLastOpenedDirectoryProperty : ObjectProperty<File> {
		if (this.lastOpenedDirectory === null) {
			this.lastOpenedDirectory = new SimpleObjectProperty<File>(this, LAST_OPENED_DIRECTORY, defaultLastOpenedDirectory) {
				override invalidated {
					var file = get
					if (!file.isDirectory) {
						set(file.parentFile)
					}
				}
			}
		}
		return this.lastOpenedDirectory
	}

	private def nameLastOpenedDirectory : String {
		name(PREFERENCES_CATEGORY_FILESYSTEM, PREFERENCES_GROUP_FILESYSTEM_PREFERREDFILES, LAST_OPENED_DIRECTORY)
	}

	private def defaultLastOpenedDirectory : File {
		nameLastOpenedDirectory.prefFile
	}

	private def resetLastOpenedDirectory {
		if (this.lastOpenedDirectory !== null) {
			this.lastOpenedDirectory.set(defaultLastOpenedDirectory)
		}
	}

	private def saveLastOpenedDirectory {
		if (this.lastOpenedDirectory !== null) {
			var file = this.lastOpenedDirectory.get
			if (file === null) {
				this.store.remove(nameLastOpenedDirectory)
			} else {
				var str = this.gson.toJson(file)
				this.store.put(nameLastOpenedDirectory, str)
			}
		}
	}

	override getLastOpenedDirectory : File {
		lastOpenedDirectoryProperty.get
	}

	override setLastOpenedDirectory(file : File) {
		lastOpenedDirectoryProperty.set(file)
	}




	var lastOpenedFile : ObjectProperty<File>

	/** Replies the property that contains the last opened file.
	 */
	def getLastOpenedFileProperty : ObjectProperty<File> {
		if (this.lastOpenedFile === null) {
			this.lastOpenedFile = new SimpleObjectProperty(this, LAST_OPENED_FILE, defaultLastOpenedFile)
		}
		return this.lastOpenedFile
	}

	private def nameLastOpenedFile : String {
		name(PREFERENCES_CATEGORY_FILESYSTEM, PREFERENCES_GROUP_FILESYSTEM_PREFERREDFILES, LAST_OPENED_FILE)
	}

	private def defaultLastOpenedFile : File {
		nameLastOpenedFile.prefFile
	}

	private def resetLastOpenedFile {
		if (this.lastOpenedFile !== null) {
			this.lastOpenedFile.set(defaultLastOpenedFile)
		}
	}

	private def saveLastOpenedFile {
		if (this.lastOpenedFile !== null) {
			var file = this.lastOpenedFile.get
			if (file === null) {
				this.store.remove(nameLastOpenedFile)
			} else {
				var str = this.gson.toJson(file)
				this.store.put(nameLastOpenedFile, str)
			}
		}
	}

	override getLastOpenedFile : File {
		lastOpenedFileProperty.get
	}

	override setLastOpenedFile(file : File) {
		lastOpenedFileProperty.set(file)
	}

	
	
	
	var simulationStartTime : DoubleProperty

	/** Replies the start time of the simulation
	 */
	def getSimulationStartTimeProperty : DoubleProperty {
		if (this.simulationStartTime === null) {
			this.simulationStartTime = new SimpleDoubleProperty(this, SIMULATION_START_TIME,
				defaultSimulationStartTime) {
				override invalidated {
					var stopProp = getSimulationStopTimeProperty
					val max = stopProp.get
					val min = get
					if (min < 0.0) {
						getSimulationStartTimeProperty.set(min)
					} else if (max < min && ( max >= 0.0 )) {
						stopProp.set(min)
					}
				}
			}
		}
		return this.simulationStartTime
	}
	
	private def nameSimulationStartTime : String {
		name(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME, SIMULATION_START_TIME)
	}

	private def defaultSimulationStartTime : double {
		nameSimulationStartTime.prefDouble(SIMULATION_START_TIME_VALUE)
	}

	private def resetSimulationStartTime {
		if (this.simulationStartTime !== null) {
			this.simulationStartTime.set(defaultSimulationStartTime)
		}
	}

	private def saveSimulationStartTime {
		if (this.simulationStartTime !== null) {
			this.store.putDouble(nameSimulationStartTime, this.simulationStartTime.get)
		}
	}

	override getSimulationStartTime : double {
		simulationStartTimeProperty.get
	}

	override setSimulationStartTime(time : double) {
		simulationStartTimeProperty.set(time)
	}



	var simulationStopTime : DoubleProperty

	/** Replies the property for storing the stop time of the simulation
	 */
	def getSimulationStopTimeProperty : DoubleProperty {
		if (this.simulationStopTime === null) {
			this.simulationStopTime = new SimpleDoubleProperty(this, SIMULATION_STOP_TIME,
				defaultSimulationStopTime) {
				override invalidated {
					val max = get
					if (!max.isNaN && ( max >= 0.0 )) {
						var startProp = getSimulationStartTimeProperty
						val min = startProp.get
						if (max < min) {
							startProp.set(max)
						}
					}
				}
			}
		}
		return this.simulationStopTime
	}

	private def nameSimulationStopTime : String {
		name(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME, SIMULATION_STOP_TIME)
	}

	private def defaultSimulationStopTime : double {
		nameSimulationStopTime.prefDouble(SIMULATION_STOP_TIME_VALUE)
	}

	private def resetSimulationStopTime {
		if (this.simulationStopTime !== null) {
			this.simulationStopTime.set(defaultSimulationStopTime)
		}
	}

	private def saveSimulationStopTime {
		if (this.simulationStopTime !== null) {
			this.store.putDouble(nameSimulationStopTime, this.simulationStopTime.get)
		}
	}

	override getSimulationStopTime : double {
		simulationStopTimeProperty.get
	}

	def setSimulationStopTime(time : double) {
		simulationStopTimeProperty.set(time)
	}




	var simulationStepDuration : DoubleProperty

	/** Replies the property for storing the simulation step duration
	 */
	def getSimulationStepDurationProperty : DoubleProperty {
		if (this.simulationStepDuration === null) {
			this.simulationStepDuration = new SimpleDoubleProperty(this, SIMULATION_TIME_STEP,
				defaultSimulationStepDuration) {
				override invalidated {
					val step = get
					if (step <= 0.0) {
						getSimulationStepDurationProperty.set(SIMULATION_TIME_STEP_VALUE)
					}
				}
			}
		}
		return this.simulationStepDuration
	}

	private def nameSimulationStepDuration : String {
		name(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME, SIMULATION_TIME_STEP)
	}

	private def defaultSimulationStepDuration : double {
		nameSimulationStepDuration.prefDouble(SIMULATION_TIME_STEP_VALUE)
	}

	private def resetSimulationStepDuration {
		if (this.simulationStepDuration !== null) {
			this.simulationStepDuration.set(defaultSimulationStepDuration)
		}
	}

	private def saveSimulationStepDuration {
		if (this.simulationStepDuration !== null) {
			this.store.putDouble(nameSimulationStepDuration, this.simulationStepDuration.get)
		}
	}

	override getSimulationStepDuration : double {
		simulationStepDurationProperty.get
	}

	override setSimulationStepDuration(time : double) {
		simulationStepDurationProperty.set(time)
	}




	var simulationLoopDelay : IntegerProperty

	/** Replies the property for storing the delay to apply to a simulation loop.
	 */
	def getSimulationLoopDelayProperty : IntegerProperty {
		if (this.simulationLoopDelay === null) {
			this.simulationLoopDelay = new SimpleIntegerProperty(this, SIMULATION_LOOP_DELAY,
				defaultSimulationLoopDelay) {
				override invalidated {
					val step = get
					if (step <= 0l) {
						getSimulationStepDurationProperty.set(0l)
					}
				}
			}
		}
		return this.simulationLoopDelay
	}

	private def nameSimulationLoopDelay : String {
		name(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME, SIMULATION_LOOP_DELAY)
	}

	private def defaultSimulationLoopDelay : int {
		nameSimulationLoopDelay.prefInt(SIMULATION_LOOP_DELAY_VALUE)
	}

	private def resetSimulationLoopDelay {
		if (this.simulationLoopDelay !== null) {
			this.simulationLoopDelay.set(defaultSimulationLoopDelay)
		}
	}

	private def saveSimulationLoopDelay {
		if (this.simulationLoopDelay !== null) {
			this.store.putDouble(nameSimulationLoopDelay, this.simulationLoopDelay.get)
		}
	}

	override getSimulationLoopDelay : int {
		simulationLoopDelayProperty.get
	}

	override setSimulationLoopDelay(delay : int) {
		simulationLoopDelayProperty.set(delay)
	}




	var simulationDefaultOsTimeFactor : DoubleProperty

	/** Replies the property for storing the delay to apply to a simulation loop.
	 */
	def getSimulationDefaultOsTimeFactorProperty : DoubleProperty {
		if (this.simulationDefaultOsTimeFactor === null) {
			this.simulationDefaultOsTimeFactor = new SimpleDoubleProperty(this, SIMULATION_DEFAULT_OS_TIME_FACTOR,
				defaultSimulationDefaultOsTimeFactor) {
				override invalidated {
					val step = get
					if (step <= 0.0) {
						getSimulationStepDurationProperty.set(0.00001)
					}
				}
			}
		}
		return this.simulationDefaultOsTimeFactor
	}

	private def nameSimulationDefaultOsTimeFactor : String {
		name(PREFERENCES_CATEGORY_SIMULATION, PREFERENCES_GROUP_SIMULATION_TIME,
			SIMULATION_DEFAULT_OS_TIME_FACTOR)
	}

	private def defaultSimulationDefaultOsTimeFactor : double {
		nameSimulationDefaultOsTimeFactor.prefDouble(SIMULATION_DEFAULT_OS_TIME_FACTOR_VALUE)
	}

	private def resetSimulationDefaultOsTimeFactor {
		if (this.simulationDefaultOsTimeFactor !== null) {
			this.simulationDefaultOsTimeFactor.set(defaultSimulationDefaultOsTimeFactor)
		}
	}

	private def saveSimulationDefaultOsTimeFactor {
		if (this.simulationDefaultOsTimeFactor !== null) {
			this.store.putDouble(nameSimulationDefaultOsTimeFactor, this.simulationDefaultOsTimeFactor.get)
		}
	}

	override getSimulationDefaultOsTimeFactor : double {
		simulationDefaultOsTimeFactorProperty.get
	}

	override setSimulationDefaultOsTimeFactor(factor : double) {
		simulationDefaultOsTimeFactorProperty.set(factor)
	}




	var logErrorColor : IntegerProperty

	/** Replies the property for storing the color of the error messages.
	 */
	def getLogErrorColorProperty : IntegerProperty {
		if (this.logErrorColor === null) {
			this.logErrorColor = new SimpleIntegerProperty(
				this,
				LOG_ERROR_COLOR, defaultLogErrorColor) {
				override invalidated {
					val step = get
					if (step < 0) {
						getSimulationStepDurationProperty.set(0)
					}
				}
			}
		}
		return this.logErrorColor
	}

	private def nameLogErrorColor : String {
		name(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS, LOG_ERROR_COLOR)
	}

	private def defaultLogErrorColor : int {
		nameLogErrorColor.prefInt(LOG_ERROR_COLOR_VALUE)
	}

	private def resetLogErrorColor {
		if (this.logErrorColor !== null) {
			this.logErrorColor.set(defaultLogErrorColor)
		}
	}

	private def saveLogErrorColor {
		if (this.logErrorColor !== null) {
			this.store.putInt(nameLogErrorColor, this.logErrorColor.get)
		}
	}

	
	def getLogErrorColor : int {
		this.logErrorColorProperty.get
	}
	
	def setLogErrorColor(color : int) {
		this.logErrorColorProperty.set(color)
	}



	var logWarningColor : IntegerProperty

	/** Replies the property for storing the color of the warning messages.
	 */
	def getLogWarningColorProperty : IntegerProperty {
		if (this.logWarningColor === null) {
			this.logWarningColor = new SimpleIntegerProperty(
				this,
				LOG_WARNING_COLOR, defaultLogWarningColor) {
				override invalidated {
					val step = get
					if (step < 0) {
						getSimulationStepDurationProperty.set(0)
					}
				}
			}
		}
		return this.logWarningColor
	}

	private def nameLogWarningColor : String {
		name(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS, LOG_WARNING_COLOR)
	}

	private def defaultLogWarningColor : int {
		nameLogWarningColor.prefInt(LOG_WARNING_COLOR_VALUE)
	}

	private def resetLogWarningColor {
		if (this.logWarningColor !== null) {
			this.logWarningColor.set(defaultLogWarningColor)
		}
	}

	private def saveLogWarningColor {
		if (this.logWarningColor !== null) {
			this.store.putInt(nameLogWarningColor, this.logWarningColor.get)
		}
	}

	def getLogWarningColor : int {
		this.logWarningColorProperty.get
	}
	
	def setLogWarningColor(color : int) {
		this.logWarningColorProperty.set(color)
	}




	var logInfoColor : IntegerProperty

	/** Replies the property for storing the color of the information messages.
	 */
	def getLogInfoColorProperty : IntegerProperty {
		if (this.logInfoColor === null) {
			this.logInfoColor = new SimpleIntegerProperty(
				this,
				LOG_INFO_COLOR, defaultLogInfoColor) {
				override invalidated {
					val step = get
					if (step < 0) {
						getSimulationStepDurationProperty.set(0)
					}
				}
			}
		}
		return this.logInfoColor
	}

	private def nameLogInfoColor : String {
		name(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_COLORS, LOG_INFO_COLOR)
	}

	private def defaultLogInfoColor : int {
		nameLogInfoColor.prefInt(LOG_INFO_COLOR_VALUE)
	}

	private def resetLogInfoColor {
		if (this.logInfoColor !== null) {
			this.logInfoColor.set(defaultLogInfoColor)
		}
	}

	private def saveLogInfoColor {
		if (this.logInfoColor !== null) {
			this.store.putInt(nameLogInfoColor, this.logInfoColor.get)
		}
	}

	def getLogInfoColor : int {
		this.logInfoColorProperty.get
	}
	
	def setLogInfoColor(color : int) {
		this.logInfoColorProperty.set(color)
	}




	var logOnConsole : BooleanProperty

	/** Replies the property for storing the flag for logging on console.
	 */
	def getLogOnConsoleProperty : BooleanProperty {
		if (this.logOnConsole === null) {
			this.logOnConsole = new SimpleBooleanProperty(
				this,
				LOG_ON_CONSOLE, defaultLogOnConsole)
		}
		return this.logOnConsole
	}

	private def nameLogOnConsole : String {
		name(PREFERENCES_CATEGORY_LOGGING, PREFERENCES_GROUP_LOGGING_GENERAL, LOG_ON_CONSOLE)
	}

	private def defaultLogOnConsole : boolean {
		nameLogOnConsole.prefBoolean(LOG_ON_CONSOLE_VALUE)
	}

	private def resetLogOnConsole {
		if (this.logOnConsole !== null) {
			this.logOnConsole.set(defaultLogOnConsole)
		}
	}

	private def saveLogOnConsole {
		if (this.logOnConsole !== null) {
			this.store.putBoolean(nameLogOnConsole, this.logOnConsole.get)
		}
	}

	def getLogOnConsole : boolean {
		this.logOnConsoleProperty.get
	}

	def setLogOnConsole(enable : boolean) {
		this.logOnConsoleProperty.set(enable)
	}




	var chartXRangeFactor : DoubleProperty

	/** Replies the property for storing the factor that is used for computing the max value along the X axis of the charts.
	 */
	def getChartXRangeFactorProperty : DoubleProperty {
		if (this.chartXRangeFactor === null) {
			this.chartXRangeFactor = new SimpleDoubleProperty(this, CHART_X_RANGE_FACTOR, defaultChartXRangeFactor) {
				override invalidated {
					val step = get
					if (step < 0.0) {
						set(Math.ulp(0.0))
					}
				}
			}
		}
		return this.chartXRangeFactor
	}

	private def nameChartXRangeFactor : String {
		name(PREFERENCES_CATEGORY_CHARTS, PREFERENCES_GROUP_CHARTS_GENERAL, CHART_X_RANGE_FACTOR)
	}

	private def defaultChartXRangeFactor : double {
		nameChartXRangeFactor.prefDouble(CHART_X_RANGE_FACTOR_VALUE)
	}

	private def resetChartXRangeFactor {
		if (this.chartXRangeFactor !== null) {
			this.chartXRangeFactor.set(defaultChartXRangeFactor)
		}
	}

	private def saveChartXRangeFactor {
		if (this.chartXRangeFactor !== null) {
			this.store.putDouble(nameChartXRangeFactor, this.chartXRangeFactor.get)
		}
	}

	def getChartXRangeFactor : double {
		this.chartXRangeFactorProperty.get
	}

	def setChartXRangeFactor(size : double) {
		this.chartXRangeFactorProperty.set(size)
	}

}
