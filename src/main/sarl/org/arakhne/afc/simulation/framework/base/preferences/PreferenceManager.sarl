/* 
 * $Id$
 * This file is a part of the Arakhne Foundation Classes, http://www.arakhne.org/afc
 * 
 * Copyright (c) 2000-2012 Stephane GALLAND.
 * Copyright (c) 2005-10, Multiagent Team, Laboratoire Systemes et Transports,
 * Universite de Technologie de Belfort-Montbeliard.
 * Copyright (c) 2013-2019 The original authors, and other authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.arakhne.afc.simulation.framework.base.preferences

import java.io.File
import java.util.prefs.Preferences
import org.arakhne.afc.vmutil.ColorNames

/**
 * Manager of preferences for a simulator.
 *
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
interface PreferenceManager {

	static class Singleton {

		package static var singleton : PreferenceManager

	}

	/** Replies the singleton. */
	static def getSingleton : PreferenceManager {
		Singleton::singleton
	}

	/** Change the singleton.
	 */
	static def setSingleton(manager : PreferenceManager) {
		Singleton::singleton = manager
	}

	/** Replies the storage for the preferences.
	 * 
	 * @param  type the type that serves as the source description. If {@code null}, the {@link PreferenceManager}
	 * type is used.
	 */
	@Pure
	static def getStorage_(type : Class<?>) : Preferences {
		var tp = type
		if (tp === null) {
			tp = typeof(PreferenceManager)
		}
		return Preferences.userNodeForPackage(tp)
	}

	/** Replies the type associated to the storage for the preferences.
	 * 
	 * @return type the type that serves as the source description.
	 */
	@Pure
	def getStorageClass : Class<?>

	/** Reset the internal properties and force the synchronization from the JAva preferences.
	 */
	def reset

	/** Force the synchronization of the properties into this manager to the storage of the Java preferences.
	 *
	 * @param force indicates if the properties stored into this manager should be written into the Java
	 *     preferences. If it is {@code true}, the properties are written and the Java preferences are
	 * synchronized with the storage system. If is it {@code false}, he Java preferences are
	 * synchronized with the storage system. The default value is {@code false}.
	 */
	def sync(force : boolean = false)




	val LAST_OPENED_DIRECTORY = "lastOpenedDirectory"

	/** Replies the last opened directory
	 */
	@Pure
	def getLastOpenedDirectory : File

	/** Change the last opened directory
	 */
	def setLastOpenedDirectory(file : File)

	
	
	
	val LAST_OPENED_FILE = "lastOpenedFile"

	/** Replies the last opened file
	 */
	@Pure
	def getLastOpenedFile : File

	/** Change the last opened file
	 */
	def setLastOpenedFile(file : File)

	
	
	
	val SIMULATION_START_TIME = "simulationStartTime"

	val SIMULATION_START_TIME_VALUE = 0.0

	/** Replies the start time of the simulation
	 */
	@Pure
	def getSimulationStartTime : double

	/** Change the start time of the simulation
	 */
	def setSimulationStartTime(time : double)


	
	val SIMULATION_STOP_TIME = "simulationStopTime"

	val SIMULATION_STOP_TIME_VALUE = Double::NaN

	/** Replies the stop time of the simulation
	 */
	@Pure
	def getSimulationStopTime : double

	/** Change the stop time of the simulation
	 */
	def setSimulationStopTime(time : double)

	
	
	val SIMULATION_TIME_STEP = "simulationTimeStep"

	val SIMULATION_TIME_STEP_VALUE = 0.5

	/** Replies the property for storing the simulation step duration
	 */
	@Pure
	def getSimulationStepDuration : double

	/** Change the property for storing the simulation step duration
	 */
	def setSimulationStepDuration(time : double)

	
	
	
	val SIMULATION_LOOP_DELAY = "simulationLoopDelay"

	val SIMULATION_LOOP_DELAY_VALUE = 0

	/** Replies the delay to apply to a simulation loop.
	 */
	def getSimulationLoopDelay : int

	/** Replies the delay to apply to a simulation loop.
	 */
	def setSimulationLoopDelay(delay : int)

	
	
	val SIMULATION_DEFAULT_OS_TIME_FACTOR = "simulationDefaultOsTimeFactory"

	val SIMULATION_DEFAULT_OS_TIME_FACTOR_VALUE = 1.0

	/** Replies the factor between the OS time and the simulation time.
	 */
	def getSimulationDefaultOsTimeFactor : double

	/** Change the factor between the OS time and the simulation time.
	 */
	def setSimulationDefaultOsTimeFactor(factor : double)




	val LOG_ERROR_COLOR = "logErrorColor"

	val LOG_ERROR_COLOR_VALUE = ColorNames::getColorFromName("red")

	/** Replies the color of the errors into the log.
	 */
	def getLogErrorColor : int

	/** Change the color of the errors into the log.
	 */
	def setLogErrorColor(color : int)




	val LOG_WARNING_COLOR = "logWarningColor"

	val LOG_WARNING_COLOR_VALUE = ColorNames::getColorFromName("orange")

	/** Replies the color of the warnings into the log.
	 */
	def getLogWarningColor : int

	/** Change the color of the warnings into the log.
	 */
	def setLogWarningColor(color : int)




	val LOG_INFO_COLOR = "logInfoColor"

	val LOG_INFO_COLOR_VALUE = ColorNames::getColorFromName("black")

	/** Replies the color of the standard messages into the log.
	 */
	def getLogInfoColor : int

	/** Change the color of the standard messages into the log.
	 */
	def setLogInfoColor(color : int)




	val LOG_ON_CONSOLE = "logOnConsole"

	val LOG_ON_CONSOLE_VALUE = false

	/** Replies if the log messages should also be printed onto the console.
	 */
	def getLogOnConsole : boolean

	/** Change if the log messages should also be printed onto the console.
	 */
	def setLogOnConsole(enable : boolean)




	val CHART_X_RANGE_FACTOR = "chartXRangeFactor"

	val CHART_X_RANGE_FACTOR_VALUE = 20.0

	/** Replies the multiplication factor that is used for computing the max value along the X axis of the charts.
	 */
	def getChartXRangeFactor : double

	/** Change the multiplication factor that is used for computing the max value along the X axis of the charts.
	 */
	def setChartXRangeFactor(factor : double)

}
